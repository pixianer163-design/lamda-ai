{-# OPTIONS_GHC -Wno-unused-top-binds #-}
module Exercise02 where

-- ============================================
-- Exercise 02: 列表操作大师
-- ============================================
-- 目标：掌握列表的高阶操作
-- 难度：★★☆☆☆
-- 提示：大部分可以用 foldl/foldr 或递归实现

-- --------------------------------------------
-- 任务 1: 实现 take（取前 n 个元素）
-- --------------------------------------------
-- myTake 3 [1,2,3,4,5] = [1,2,3]
-- myTake 0 [1,2,3] = []
-- myTake 5 [1,2] = [1,2]

myTake :: Int -> [a] -> [a]
myTake 0 _ = []
myTake n (x:xs) = error "TODO: 实现 take"
myTake _ [] = []

-- --------------------------------------------
-- 任务 2: 实现 drop（丢弃前 n 个元素）
-- --------------------------------------------
-- myDrop 2 [1,2,3,4,5] = [3,4,5]
-- myDrop 0 xs = xs

myDrop :: Int -> [a] -> [a]
myDrop 0 xs = xs
myDrop n (_:xs) = error "TODO: 实现 drop"
myDrop _ [] = []

-- --------------------------------------------
-- 任务 3: 实现 zip（合并两个列表）
-- --------------------------------------------
-- myZip [1,2,3] ['a','b'] = [(1,'a'), (2,'b')]
-- 长度不同时，取较短的列表

myZip :: [a] -> [b] -> [(a, b)]
myZip (x:xs) (y:ys) = error "TODO: 实现 zip"
myZip _ _ = []

-- --------------------------------------------
-- 任务 4: 实现 elem（检查元素是否在列表中）
-- --------------------------------------------
-- myElem 3 [1,2,3,4] = True
-- myElem 5 [1,2,3,4] = False

myElem :: Eq a => a -> [a] -> Bool
myElem x [] = False
myElem x (y:ys) = error "TODO: 实现 elem"

-- --------------------------------------------
-- 任务 5: 实现 nub（去重，保留第一次出现的）
-- --------------------------------------------
-- nub [1,2,1,3,2,4] = [1,2,3,4]
-- 提示：需要一个辅助函数检查元素是否已在结果中

nub :: Eq a => [a] -> [a]
nub [] = []
nub (x:xs) = error "TODO: 实现 nub"

-- --------------------------------------------
-- 任务 6: 实现 group（连续相同元素分组）
-- --------------------------------------------
-- group [1,1,1,2,3,3,1] = [[1,1,1],[2],[3,3],[1]]
-- 提示：使用 span 或手动递归

group :: Eq a => [a] -> [[a]]
group [] = []
group (x:xs) = error "TODO: 实现 group"

-- --------------------------------------------
-- 任务 7: 实现 splitAt（在指定位置分割列表）
-- --------------------------------------------
-- splitAt 3 [1,2,3,4,5,6] = ([1,2,3], [4,5,6])
-- splitAt 0 xs = ([], xs)
-- splitAt 100 xs = (xs, [])  -- n 大于列表长度

splitAt :: Int -> [a] -> ([a], [a])
splitAt 0 xs = ([], xs)
splitAt n xs = error "TODO: 实现 splitAt"

-- --------------------------------------------
-- 任务 8: 实现 intersperse（在元素间插入分隔符）
-- --------------------------------------------
-- intersperse ',' "abc" = "a,b,c"
-- intersperse 0 [1,2,3] = [1,0,2,0,3]
-- intersperse x [] = []
-- intersperse x [y] = [y]

intersperse :: a -> [a] -> [a]
intersperse _ [] = []
intersperse _ [x] = [x]
intersperse sep (x:xs) = error "TODO: 实现 intersperse"

-- ============================================
-- 进阶挑战（可选）
-- ============================================

-- 挑战 1: 使用 foldr 实现 map
mapWithFoldr :: (a -> b) -> [a] -> [b]
mapWithFoldr f xs = error "TODO: 使用 foldr 实现 map"

-- 挑战 2: 使用 foldl 实现 reverse
reverseWithFoldl :: [a] -> [a]
reverseWithFoldl xs = error "TODO: 使用 foldl 实现 reverse"

-- ============================================
-- 测试数据
-- ============================================
-- 在 GHCi 中测试：
-- :load exercises/Exercise02.hs
-- myTake 3 [1,2,3,4,5] 应该返回 [1,2,3]
-- myDrop 2 [1,2,3,4] 应该返回 [3,4]
-- myZip [1,2] "ab" 应该返回 [(1,'a'), (2,'b')]
-- myElem 2 [1,2,3] 应该返回 True
-- nub [1,2,1,3,2] 应该返回 [1,2,3]
-- group "aaabcca" 应该返回 ["aaa","b","cc","a"]
-- splitAt 3 [1,2,3,4,5] 应该返回 ([1,2,3],[4,5])
-- intersperse ',' "abc" 应该返回 "a,b,c"
